// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: elandnode/deed/v1/tx.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { RequestType, requestTypeFromJSON, requestTypeToJSON, Witness } from "./deed";

export const protobufPackage = "elandnode.deed.v1";

export interface MsgApproveDeedRequest {
  creator: string;
  decision: boolean;
  deedNumber: string;
  remarks: string;
}

export interface MsgApproveDeedRequestResponse {
  status: string;
  code: number;
  message: string;
  data: string;
  requestId: string;
  timestamp: string;
}

export interface MsgRequestDeed {
  creator: string;
  deedNumber: string;
  requestType: RequestType;
}

export interface MsgRequestDeedResponse {
  status: string;
  code: number;
  message: string;
  data: string;
  requestId: string;
  timestamp: string;
}

/** MsgPrepareDeed - Notary prepares and signs a draft deed */
export interface MsgPrepareDeed {
  creator: string;
  deedNumber: string;
  folioId: string;
  newOwnerNic: string;
  notarySignature: string;
  issueDate: string;
  stampDuty: string[];
}

export interface DeedResponse {
  deedNumber: string;
  /** "prepared" */
  status: string;
}

export interface MsgPrepareDeedResponse {
  status: string;
  code: number;
  message: string;
  data: DeedResponse | undefined;
  requestId: string;
  timestamp: string;
}

export interface MsgIssueDeed {
  notary: string;
  deedId: string;
  parcelId: string;
  folioId: string;
  deedNumber: string;
  sellerId: string;
  buyerId: string;
  registryId: string;
  agreementCid: string;
  witnesses: Witness[];
  creator: string;
}

export interface MsgIssueDeedResponse {
  status: string;
  code: number;
  message: string;
  data: string;
  requestId: string;
  timestamp: string;
}

function createBaseMsgApproveDeedRequest(): MsgApproveDeedRequest {
  return { creator: "", decision: false, deedNumber: "", remarks: "" };
}

export const MsgApproveDeedRequest: MessageFns<MsgApproveDeedRequest> = {
  encode(message: MsgApproveDeedRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.decision !== false) {
      writer.uint32(16).bool(message.decision);
    }
    if (message.deedNumber !== "") {
      writer.uint32(26).string(message.deedNumber);
    }
    if (message.remarks !== "") {
      writer.uint32(34).string(message.remarks);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgApproveDeedRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgApproveDeedRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.decision = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deedNumber = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.remarks = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgApproveDeedRequest {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      decision: isSet(object.decision) ? globalThis.Boolean(object.decision) : false,
      deedNumber: isSet(object.deedNumber) ? globalThis.String(object.deedNumber) : "",
      remarks: isSet(object.remarks) ? globalThis.String(object.remarks) : "",
    };
  },

  toJSON(message: MsgApproveDeedRequest): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.decision !== false) {
      obj.decision = message.decision;
    }
    if (message.deedNumber !== "") {
      obj.deedNumber = message.deedNumber;
    }
    if (message.remarks !== "") {
      obj.remarks = message.remarks;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgApproveDeedRequest>, I>>(base?: I): MsgApproveDeedRequest {
    return MsgApproveDeedRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgApproveDeedRequest>, I>>(object: I): MsgApproveDeedRequest {
    const message = createBaseMsgApproveDeedRequest();
    message.creator = object.creator ?? "";
    message.decision = object.decision ?? false;
    message.deedNumber = object.deedNumber ?? "";
    message.remarks = object.remarks ?? "";
    return message;
  },
};

function createBaseMsgApproveDeedRequestResponse(): MsgApproveDeedRequestResponse {
  return { status: "", code: 0, message: "", data: "", requestId: "", timestamp: "" };
}

export const MsgApproveDeedRequestResponse: MessageFns<MsgApproveDeedRequestResponse> = {
  encode(message: MsgApproveDeedRequestResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    if (message.code !== 0) {
      writer.uint32(16).int32(message.code);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.data !== "") {
      writer.uint32(34).string(message.data);
    }
    if (message.requestId !== "") {
      writer.uint32(42).string(message.requestId);
    }
    if (message.timestamp !== "") {
      writer.uint32(50).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgApproveDeedRequestResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgApproveDeedRequestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.code = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.data = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgApproveDeedRequestResponse {
    return {
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: isSet(object.data) ? globalThis.String(object.data) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: MsgApproveDeedRequestResponse): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data !== "") {
      obj.data = message.data;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgApproveDeedRequestResponse>, I>>(base?: I): MsgApproveDeedRequestResponse {
    return MsgApproveDeedRequestResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgApproveDeedRequestResponse>, I>>(
    object: I,
  ): MsgApproveDeedRequestResponse {
    const message = createBaseMsgApproveDeedRequestResponse();
    message.status = object.status ?? "";
    message.code = object.code ?? 0;
    message.message = object.message ?? "";
    message.data = object.data ?? "";
    message.requestId = object.requestId ?? "";
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseMsgRequestDeed(): MsgRequestDeed {
  return { creator: "", deedNumber: "", requestType: 0 };
}

export const MsgRequestDeed: MessageFns<MsgRequestDeed> = {
  encode(message: MsgRequestDeed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.deedNumber !== "") {
      writer.uint32(18).string(message.deedNumber);
    }
    if (message.requestType !== 0) {
      writer.uint32(24).int32(message.requestType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRequestDeed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRequestDeed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.deedNumber = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.requestType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRequestDeed {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      deedNumber: isSet(object.deedNumber) ? globalThis.String(object.deedNumber) : "",
      requestType: isSet(object.requestType) ? requestTypeFromJSON(object.requestType) : 0,
    };
  },

  toJSON(message: MsgRequestDeed): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.deedNumber !== "") {
      obj.deedNumber = message.deedNumber;
    }
    if (message.requestType !== 0) {
      obj.requestType = requestTypeToJSON(message.requestType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRequestDeed>, I>>(base?: I): MsgRequestDeed {
    return MsgRequestDeed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRequestDeed>, I>>(object: I): MsgRequestDeed {
    const message = createBaseMsgRequestDeed();
    message.creator = object.creator ?? "";
    message.deedNumber = object.deedNumber ?? "";
    message.requestType = object.requestType ?? 0;
    return message;
  },
};

function createBaseMsgRequestDeedResponse(): MsgRequestDeedResponse {
  return { status: "", code: 0, message: "", data: "", requestId: "", timestamp: "" };
}

export const MsgRequestDeedResponse: MessageFns<MsgRequestDeedResponse> = {
  encode(message: MsgRequestDeedResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    if (message.code !== 0) {
      writer.uint32(16).int32(message.code);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.data !== "") {
      writer.uint32(34).string(message.data);
    }
    if (message.requestId !== "") {
      writer.uint32(42).string(message.requestId);
    }
    if (message.timestamp !== "") {
      writer.uint32(50).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRequestDeedResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRequestDeedResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.code = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.data = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRequestDeedResponse {
    return {
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: isSet(object.data) ? globalThis.String(object.data) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: MsgRequestDeedResponse): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data !== "") {
      obj.data = message.data;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRequestDeedResponse>, I>>(base?: I): MsgRequestDeedResponse {
    return MsgRequestDeedResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRequestDeedResponse>, I>>(object: I): MsgRequestDeedResponse {
    const message = createBaseMsgRequestDeedResponse();
    message.status = object.status ?? "";
    message.code = object.code ?? 0;
    message.message = object.message ?? "";
    message.data = object.data ?? "";
    message.requestId = object.requestId ?? "";
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseMsgPrepareDeed(): MsgPrepareDeed {
  return {
    creator: "",
    deedNumber: "",
    folioId: "",
    newOwnerNic: "",
    notarySignature: "",
    issueDate: "",
    stampDuty: [],
  };
}

export const MsgPrepareDeed: MessageFns<MsgPrepareDeed> = {
  encode(message: MsgPrepareDeed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.deedNumber !== "") {
      writer.uint32(18).string(message.deedNumber);
    }
    if (message.folioId !== "") {
      writer.uint32(26).string(message.folioId);
    }
    if (message.newOwnerNic !== "") {
      writer.uint32(34).string(message.newOwnerNic);
    }
    if (message.notarySignature !== "") {
      writer.uint32(42).string(message.notarySignature);
    }
    if (message.issueDate !== "") {
      writer.uint32(50).string(message.issueDate);
    }
    for (const v of message.stampDuty) {
      writer.uint32(58).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgPrepareDeed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPrepareDeed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.deedNumber = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.folioId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.newOwnerNic = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.notarySignature = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.issueDate = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.stampDuty.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgPrepareDeed {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      deedNumber: isSet(object.deedNumber) ? globalThis.String(object.deedNumber) : "",
      folioId: isSet(object.folioId) ? globalThis.String(object.folioId) : "",
      newOwnerNic: isSet(object.newOwnerNic) ? globalThis.String(object.newOwnerNic) : "",
      notarySignature: isSet(object.notarySignature) ? globalThis.String(object.notarySignature) : "",
      issueDate: isSet(object.issueDate) ? globalThis.String(object.issueDate) : "",
      stampDuty: globalThis.Array.isArray(object?.stampDuty)
        ? object.stampDuty.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: MsgPrepareDeed): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.deedNumber !== "") {
      obj.deedNumber = message.deedNumber;
    }
    if (message.folioId !== "") {
      obj.folioId = message.folioId;
    }
    if (message.newOwnerNic !== "") {
      obj.newOwnerNic = message.newOwnerNic;
    }
    if (message.notarySignature !== "") {
      obj.notarySignature = message.notarySignature;
    }
    if (message.issueDate !== "") {
      obj.issueDate = message.issueDate;
    }
    if (message.stampDuty?.length) {
      obj.stampDuty = message.stampDuty;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgPrepareDeed>, I>>(base?: I): MsgPrepareDeed {
    return MsgPrepareDeed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgPrepareDeed>, I>>(object: I): MsgPrepareDeed {
    const message = createBaseMsgPrepareDeed();
    message.creator = object.creator ?? "";
    message.deedNumber = object.deedNumber ?? "";
    message.folioId = object.folioId ?? "";
    message.newOwnerNic = object.newOwnerNic ?? "";
    message.notarySignature = object.notarySignature ?? "";
    message.issueDate = object.issueDate ?? "";
    message.stampDuty = object.stampDuty?.map((e) => e) || [];
    return message;
  },
};

function createBaseDeedResponse(): DeedResponse {
  return { deedNumber: "", status: "" };
}

export const DeedResponse: MessageFns<DeedResponse> = {
  encode(message: DeedResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deedNumber !== "") {
      writer.uint32(10).string(message.deedNumber);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeedResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeedResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deedNumber = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeedResponse {
    return {
      deedNumber: isSet(object.deedNumber) ? globalThis.String(object.deedNumber) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
    };
  },

  toJSON(message: DeedResponse): unknown {
    const obj: any = {};
    if (message.deedNumber !== "") {
      obj.deedNumber = message.deedNumber;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeedResponse>, I>>(base?: I): DeedResponse {
    return DeedResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeedResponse>, I>>(object: I): DeedResponse {
    const message = createBaseDeedResponse();
    message.deedNumber = object.deedNumber ?? "";
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseMsgPrepareDeedResponse(): MsgPrepareDeedResponse {
  return { status: "", code: 0, message: "", data: undefined, requestId: "", timestamp: "" };
}

export const MsgPrepareDeedResponse: MessageFns<MsgPrepareDeedResponse> = {
  encode(message: MsgPrepareDeedResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    if (message.code !== 0) {
      writer.uint32(16).int32(message.code);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.data !== undefined) {
      DeedResponse.encode(message.data, writer.uint32(34).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(42).string(message.requestId);
    }
    if (message.timestamp !== "") {
      writer.uint32(50).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgPrepareDeedResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPrepareDeedResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.code = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.data = DeedResponse.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgPrepareDeedResponse {
    return {
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: isSet(object.data) ? DeedResponse.fromJSON(object.data) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: MsgPrepareDeedResponse): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data !== undefined) {
      obj.data = DeedResponse.toJSON(message.data);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgPrepareDeedResponse>, I>>(base?: I): MsgPrepareDeedResponse {
    return MsgPrepareDeedResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgPrepareDeedResponse>, I>>(object: I): MsgPrepareDeedResponse {
    const message = createBaseMsgPrepareDeedResponse();
    message.status = object.status ?? "";
    message.code = object.code ?? 0;
    message.message = object.message ?? "";
    message.data = (object.data !== undefined && object.data !== null)
      ? DeedResponse.fromPartial(object.data)
      : undefined;
    message.requestId = object.requestId ?? "";
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseMsgIssueDeed(): MsgIssueDeed {
  return {
    notary: "",
    deedId: "",
    parcelId: "",
    folioId: "",
    deedNumber: "",
    sellerId: "",
    buyerId: "",
    registryId: "",
    agreementCid: "",
    witnesses: [],
    creator: "",
  };
}

export const MsgIssueDeed: MessageFns<MsgIssueDeed> = {
  encode(message: MsgIssueDeed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.notary !== "") {
      writer.uint32(10).string(message.notary);
    }
    if (message.deedId !== "") {
      writer.uint32(18).string(message.deedId);
    }
    if (message.parcelId !== "") {
      writer.uint32(26).string(message.parcelId);
    }
    if (message.folioId !== "") {
      writer.uint32(34).string(message.folioId);
    }
    if (message.deedNumber !== "") {
      writer.uint32(42).string(message.deedNumber);
    }
    if (message.sellerId !== "") {
      writer.uint32(50).string(message.sellerId);
    }
    if (message.buyerId !== "") {
      writer.uint32(58).string(message.buyerId);
    }
    if (message.registryId !== "") {
      writer.uint32(66).string(message.registryId);
    }
    if (message.agreementCid !== "") {
      writer.uint32(74).string(message.agreementCid);
    }
    for (const v of message.witnesses) {
      Witness.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.creator !== "") {
      writer.uint32(90).string(message.creator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgIssueDeed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgIssueDeed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.notary = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.deedId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.parcelId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.folioId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.deedNumber = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sellerId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.buyerId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.registryId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.agreementCid = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.witnesses.push(Witness.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgIssueDeed {
    return {
      notary: isSet(object.notary) ? globalThis.String(object.notary) : "",
      deedId: isSet(object.deedId) ? globalThis.String(object.deedId) : "",
      parcelId: isSet(object.parcelId) ? globalThis.String(object.parcelId) : "",
      folioId: isSet(object.folioId) ? globalThis.String(object.folioId) : "",
      deedNumber: isSet(object.deedNumber) ? globalThis.String(object.deedNumber) : "",
      sellerId: isSet(object.sellerId) ? globalThis.String(object.sellerId) : "",
      buyerId: isSet(object.buyerId) ? globalThis.String(object.buyerId) : "",
      registryId: isSet(object.registryId) ? globalThis.String(object.registryId) : "",
      agreementCid: isSet(object.agreementCid) ? globalThis.String(object.agreementCid) : "",
      witnesses: globalThis.Array.isArray(object?.witnesses)
        ? object.witnesses.map((e: any) => Witness.fromJSON(e))
        : [],
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
    };
  },

  toJSON(message: MsgIssueDeed): unknown {
    const obj: any = {};
    if (message.notary !== "") {
      obj.notary = message.notary;
    }
    if (message.deedId !== "") {
      obj.deedId = message.deedId;
    }
    if (message.parcelId !== "") {
      obj.parcelId = message.parcelId;
    }
    if (message.folioId !== "") {
      obj.folioId = message.folioId;
    }
    if (message.deedNumber !== "") {
      obj.deedNumber = message.deedNumber;
    }
    if (message.sellerId !== "") {
      obj.sellerId = message.sellerId;
    }
    if (message.buyerId !== "") {
      obj.buyerId = message.buyerId;
    }
    if (message.registryId !== "") {
      obj.registryId = message.registryId;
    }
    if (message.agreementCid !== "") {
      obj.agreementCid = message.agreementCid;
    }
    if (message.witnesses?.length) {
      obj.witnesses = message.witnesses.map((e) => Witness.toJSON(e));
    }
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgIssueDeed>, I>>(base?: I): MsgIssueDeed {
    return MsgIssueDeed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgIssueDeed>, I>>(object: I): MsgIssueDeed {
    const message = createBaseMsgIssueDeed();
    message.notary = object.notary ?? "";
    message.deedId = object.deedId ?? "";
    message.parcelId = object.parcelId ?? "";
    message.folioId = object.folioId ?? "";
    message.deedNumber = object.deedNumber ?? "";
    message.sellerId = object.sellerId ?? "";
    message.buyerId = object.buyerId ?? "";
    message.registryId = object.registryId ?? "";
    message.agreementCid = object.agreementCid ?? "";
    message.witnesses = object.witnesses?.map((e) => Witness.fromPartial(e)) || [];
    message.creator = object.creator ?? "";
    return message;
  },
};

function createBaseMsgIssueDeedResponse(): MsgIssueDeedResponse {
  return { status: "", code: 0, message: "", data: "", requestId: "", timestamp: "" };
}

export const MsgIssueDeedResponse: MessageFns<MsgIssueDeedResponse> = {
  encode(message: MsgIssueDeedResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    if (message.code !== 0) {
      writer.uint32(16).int32(message.code);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.data !== "") {
      writer.uint32(34).string(message.data);
    }
    if (message.requestId !== "") {
      writer.uint32(42).string(message.requestId);
    }
    if (message.timestamp !== "") {
      writer.uint32(50).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgIssueDeedResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgIssueDeedResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.code = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.data = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgIssueDeedResponse {
    return {
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: isSet(object.data) ? globalThis.String(object.data) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: MsgIssueDeedResponse): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data !== "") {
      obj.data = message.data;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgIssueDeedResponse>, I>>(base?: I): MsgIssueDeedResponse {
    return MsgIssueDeedResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgIssueDeedResponse>, I>>(object: I): MsgIssueDeedResponse {
    const message = createBaseMsgIssueDeedResponse();
    message.status = object.status ?? "";
    message.code = object.code ?? 0;
    message.message = object.message ?? "";
    message.data = object.data ?? "";
    message.requestId = object.requestId ?? "";
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

/** Msg defines the Msg service. */
export interface Msg {
  /**
   * IssueDeed allows a Land Registry Officer to officially issue a deed after all verifications are complete.
   * It finalizes the deed record on-chain, assigns it to the correct folio, and emits a `deed_issued` event.
   * Only authorized registry officers can execute this transaction.
   */
  IssueDeed(request: MsgIssueDeed): Promise<MsgIssueDeedResponse>;
  /**
   * PrepareDeed allows a Notary to prepare a deed draft for a specific folio and new owner.
   * The deed remains pending until it is officially issued by a Registry Officer.
   * Emits a `deed_prepared` event that can be used by other modules (e.g., folio) to mark pending deeds.
   */
  PrepareDeed(request: MsgPrepareDeed): Promise<MsgPrepareDeedResponse>;
  /**
   * RequestDeed allows a property owner or notary to request a certified copy of a deed.
   * The request is recorded on-chain and awaits approval by the Registry Office.
   */
  RequestDeed(request: MsgRequestDeed): Promise<MsgRequestDeedResponse>;
  /**
   * ApproveDeedRequest allows a Registry Officer to approve a previously submitted deed copy request.
   * Upon approval, the request status is updated and the requester can retrieve the certified deed.
   */
  ApproveDeedRequest(request: MsgApproveDeedRequest): Promise<MsgApproveDeedRequestResponse>;
}

export const MsgServiceName = "elandnode.deed.v1.Msg";
export class MsgClientImpl implements Msg {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || MsgServiceName;
    this.rpc = rpc;
    this.IssueDeed = this.IssueDeed.bind(this);
    this.PrepareDeed = this.PrepareDeed.bind(this);
    this.RequestDeed = this.RequestDeed.bind(this);
    this.ApproveDeedRequest = this.ApproveDeedRequest.bind(this);
  }
  IssueDeed(request: MsgIssueDeed): Promise<MsgIssueDeedResponse> {
    const data = MsgIssueDeed.encode(request).finish();
    const promise = this.rpc.request(this.service, "IssueDeed", data);
    return promise.then((data) => MsgIssueDeedResponse.decode(new BinaryReader(data)));
  }

  PrepareDeed(request: MsgPrepareDeed): Promise<MsgPrepareDeedResponse> {
    const data = MsgPrepareDeed.encode(request).finish();
    const promise = this.rpc.request(this.service, "PrepareDeed", data);
    return promise.then((data) => MsgPrepareDeedResponse.decode(new BinaryReader(data)));
  }

  RequestDeed(request: MsgRequestDeed): Promise<MsgRequestDeedResponse> {
    const data = MsgRequestDeed.encode(request).finish();
    const promise = this.rpc.request(this.service, "RequestDeed", data);
    return promise.then((data) => MsgRequestDeedResponse.decode(new BinaryReader(data)));
  }

  ApproveDeedRequest(request: MsgApproveDeedRequest): Promise<MsgApproveDeedRequestResponse> {
    const data = MsgApproveDeedRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ApproveDeedRequest", data);
    return promise.then((data) => MsgApproveDeedRequestResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
